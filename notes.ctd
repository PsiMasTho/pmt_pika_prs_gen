<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node name="IntervalContainer" unique_id="2" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161357" ts_lastsave="1745161415">
    <rich_text>  0INSIDE    1INSIDE    2INSIDE
0 [a0, b0] 1 [a1, b1] 2 [a2, b2] 3
 
LOWERS = [a0, a1, a2, ...]
UPPERS = [b0, b1, b2, ...]</rich_text>
  </node>
  <node name="CodeGuidelines" unique_id="6" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161695" ts_lastsave="1745161695">
    <node name="Sections" unique_id="5" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161469" ts_lastsave="1745161534">
      <rich_text>// -$ Types / Constants $-

// -$ Data $-

// -$ Functions $-
// --$ Lifetime $--
// --$ Operators $--
// --$ Inherited: foo::bar::Baz $--
// --$ Other $--</rich_text>
    </node>
    <node name="Conventions" unique_id="7" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161743" ts_lastsave="1745161748">
      <rich_text>Concepts in a nested ccpt namespace

type traits in a nested trait namespace,

private use things that are forced to be in headers, should be in a detail namespace

class type aliases should end in "Type"

declare and define getters before setters if possible

boolean functions start with "is_"</rich_text>
    </node>
  </node>
  <node name="ScratchPad" unique_id="4" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="#e5a50a" ts_creation="1745161415" ts_lastsave="1749909554">
    <rich_text>Rename:
parsert: smrt
parsect: smct

State machine runtime (GenericStateMachine?) should take a CRTP interface, specifies a std::integral parameter
-&gt;Generated state machines inherit from this, can use the least needed width integer
-&gt;StateMachine class used for building also inherits from this with uint64_t and thus can also be dynamically run

smrt should provide shallow bitsets

-----------------------------------------------
add some way to iterate over the interval numbers in the interval_{map,set}
+ rename overlap to "clone_and" + "inplace_and", then implement other bitwise operations
+ rename "merge" to "clone_or" + "inplace_or"
+ implement "clone_not" + "inplace_not" &lt;- test this against an interval_set&lt;uint8_t&gt; and a bitset with a size of uint8t_max
+ implement "popcnt"

-----------------------------------------------
bitset or needs to increase size if needed just like and needs to decrease it
-----------------------------------------------
minimizer may not be handling sink state properly now
-----------------------------------------------
for accept bitsets we should not rely on them being the same size, should be possible because and + or may be all we need
+ countl_zero can be wrapped to handle an empty bitset diffrently

-
for handling comment loopbacks, refator out function, take a range of min max, create a huge interval, erase from it all intervals in current state, loop over the remainig and point to 0

----
GraphWriter::accepts_to_label_default can already use the intervals instead of being lazy
---
GrammarData
TerminalStateMachineBuilder
ParserBuilder
---
no need to manually set expression type in TerminalStateMachinePartBuilder, dispatch() can deduce it
--
rename "Rule" to "Nonterminal" ?
---
should add something like GrmBoolean
--
GrammarData only has _whitespace_definition,   pmt::base::IntervalSet&lt;pmt::util::smrt::SymbolType&gt; _whitespace_symbols should be somewhere else like LexerBuilder
---
rename grm_* stuff to own_*
----
change the LexerTables data to private once i figure out how it needs to be accessed
----
implement multi symbol whitespace
rename whitespace to skip
need to check if whitespace conflicts with comment open / multiple starting states is enough of an error?
---
implement case sensitivity
--
fix "" string in terminal definition resulting in null byte
--
emit ids in a list and actually include those where needed
--
use smallest possible integers when emitting lexer or parser tables, offsets is an easy candidate
---
use eytzinger layout and precompute a prev table, use smallest type needed
--
shift the upper and lower bounds by + 1 then we can use small types
--
make skel base class or something similar in pmt_util
--
graphwriter needs to write symbol edges, seperate by symbol kind
this can be done somewhat efficiently by checking all used symbol kinds and then 'and'ing them together with the symbols to
split them by kind, then they need to be written by-kind
----
newline tables passed to the generic lexer
-&gt; take alphabet that loops back to state 0 from the lexer state machine
---
graphviz nodes should be first defined in the proper order
--
rename @start to @skip ?
----
LexerTables::terminal_label_to_index is slow
--
set up the start and end in setup_parser_state_machine
--
rename rule things in the grammar to nonterminal
--
end states looping on themselves is fine in nonterminals, just means it needs lookahead
--
rule building from expressions not done right, probably needs a stack of rule opens but just a map of closes
----
every nonterminal identifier needs to create an open state, but it should point to an existing definition node if on the stack,
the created open + should point to the existing definition, the - should become outgoing
----
minimizer doesn't work right with empty state machines
---
can unpack a rule in the state machine if it cannot reach one of its nonterminal states from any close transition
---
rename terminals and nonterminals to accepts where applicable
--
id_names to id_strings in the generated parsing and lexing tables
--
add a function for returning a span of acceptible terminals from parsertablesbase
+
calculate masks near the end of parsertablebuilder and check for conflicts
--
some modifiers may be incompatible like unpack and id
---
check conflicts twice, one for the nonterminal state machine, one for lookahead,
+
no need to check transition masks in the ParserTableBuilder (?)
---
implement rank feature
hidden terminals
seperate symbol kind instead of bitmasking
---
add a chartype grammar property
---
start accept index needs to be set for each transition mask again
---
parser transitions now need to be written differently since kinds are stored seperately
-&gt; TerminalTransitions
-&gt; HiddenTerminalTransitions
-&gt; OpenTransitions
-&gt; CloseTransitions
-&gt; ConflictTransitions
+
rename upper and lower bounds in lexer skell to the symbol name smt like CharacterSymbolTransitions
---
process_range_stage_0 needs to add a range directly instead of iterating
--
common code can be factored out of lexer_table_writer and parser_table_writer
+
finish changing c style arrays to std::array in the skel files
---
fix duplicate rule definitions
---
conflict resolution not fully working yet, see sandbox_17
+
factor out lookahead generation into another class
---
replace size_t with AcceptsIndexType
---
genericparser should query if a terminal is hidden or not instead of trying to get next state twice
--
name "terminals" visible_terminals to distinguish from hidden ?
---
emit hidden terminal transition masks in parser_table_writer
--
graph writer callbacks should take entire IntervalSets now
--
terminal conflict checking is a bit weird now because it ignores whitespace
+
force whitespace between tokens - toggle with a grammar property?
@whitespace_setting = optional / mandatory &lt;- something like that
+
maybe optional whitespace can just be built into the definition like
@whitespace = " "? makes it optional... this doesnt handle comments
+
===&gt; terminal conflicts should not be a fatal error, just warning and the whitespace and comments should be left as-is
---
genericparser should probably have a static parse fn
---
transformations need to happen on the AST after parsing, the newly created Ids should come after in the enum
---
rm *.svg *.dot; cls &amp;&amp; ~/pmt_parserbuilder_tui -g ~/repos/pmt/src/pmt/parserbuilder/grammar.grm -sl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables.cpp -hl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables.hpp -cl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables-inl.hpp -sp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables.cpp -hp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables.hpp -cp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables-inl.hpp -t ~/repos/pmt/src/pmt/parserbuilder/grammar.grm
--
just emit one inl file?
---
transition masks need their own offsets
---
lower bounds + upper bounds + values should be stored back to back since size is the same
kind lookup should also be done in a back to back &lt;kinds&gt; -&gt; &lt;offsets&gt; sorted table
--
rewrite grammar so that repetition expr and sequence modifier and hide is in front
--
inlining should be done on the grammar directly
--
nonterminal inliner should work on the AST alone?
--
define terminal actions
!hide_terminal = {
	$.hide()
};
+ can use logical operators

!parens_to_square = {
 $.empty() || (($.front() == "(" &amp;&amp; $.back() == ")") &amp;&amp; $.front() = "[", $.front() = "]")
};
--
ids should not be seperated for terminals and nonterminals, they should be shared
--
factor out pushing for NonterminalInliner::perform_inline and NonterminalInliner::check_inlineable
--
Generated files:
 LexerTables.{h,c}pp: Inherits from LexerTablesBase
 ParserTables.{h,c}pp: Inherits from ParserTablesBase
 
 GrammarTables.{h,c}pp: Inherits from GrammarTablesBase
 OR (?)
 id_constants-inl.hpp
 id_strings-inl.hpp
 --
 PostParse should create eoi terminal definition, it should also augment the grammar and put eoi after the start rule</rich_text>
  </node>
  <node name="Code dump" unique_id="8" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1746822397" ts_lastsave="1746979052">
    <rich_text> size_t max = 0;
 IntervalSet&lt;StateNrType&gt; state_nrs = _lexer_state_machine.get_state_nrs();
 state_nrs.for_each_key(
  [&amp;](StateNrType state_nr_) {
   State const* state = _lexer_state_machine.get_state(state_nr_);
   Bitset const&amp; accepts = state-&gt;get_accepts();
   size_t const furthest = accepts.size() - accepts.countr(false);
   max = std::max(max, furthest);
  });

  return max;
  ----
  void NonterminalStateMachinePartBuilder::process_nonterminal_identifier_stage_0(size_t frame_idx_){
 GenericAst const&amp; expr_cur = *_callstack[frame_idx_]._expr_cur_path.resolve(*_ast_root);

 std::string const&amp; nonterminal_label = expr_cur.get_string();
 _callstack[frame_idx_]._nonterminal_idx_cur = _fn_rev_lookup_nonterminal_label(nonterminal_label);

 auto itr_close = _nonterminal_idx_to_close_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur);
 if (itr_close == _nonterminal_idx_to_close_state_nr.end()) {
  itr_close = _nonterminal_idx_to_close_state_nr.emplace(_callstack[frame_idx_]._nonterminal_idx_cur, _dest_state_machine-&gt;create_new_state()).first;
  State&amp; state_close = *_dest_state_machine-&gt;get_state(itr_close-&gt;second);
  state_close.get_accepts().resize(_callstack[frame_idx_]._nonterminal_idx_cur + 1, false);
  state_close.get_accepts().set(_callstack[frame_idx_]._nonterminal_idx_cur, true);
 }

 auto itr_open = _nonterminal_idx_to_open_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur);
 if (itr_open == _nonterminal_idx_to_open_state_nr.end()) {
  itr_open = _nonterminal_idx_to_open_state_nr.emplace(_callstack[frame_idx_]._nonterminal_idx_cur, _dest_state_machine-&gt;create_new_state()).first;
  ++_callstack[frame_idx_]._stage;
  _keep_current_frame = true;
  _callstack.emplace_back();
  _callstack.back()._expr_cur_path = _fn_lookup_nonterminal_definition(_callstack[frame_idx_]._nonterminal_idx_cur);
  _callstack.back()._expression_type = _callstack.back()._expr_cur_path.resolve(*_ast_root)-&gt;get_id();
 } else {
  _ret_part.connect_outgoing_transitions_to(itr_open-&gt;second, *_dest_state_machine);
  _ret_part.set_incoming_state_nr(itr_open-&gt;second);
  _ret_part.add_outgoing_symbol_transition(itr_open-&gt;second, Symbol(SymbolKindClose, _callstack[frame_idx_]._nonterminal_idx_cur));
 }
}

void NonterminalStateMachinePartBuilder::process_nonterminal_identifier_stage_1(size_t frame_idx_){
 StateNrType const state_nr_incoming = _nonterminal_idx_to_open_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur)-&gt;second;
 State&amp; state_incoming = *_dest_state_machine-&gt;get_state(state_nr_incoming);
 StateNrType const state_nr_close = _nonterminal_idx_to_close_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur)-&gt;second;
 state_incoming.add_symbol_transition(Symbol(SymbolKindOpen, SymbolValueOpen), *_ret_part.get_incoming_state_nr());
 _ret_part.set_incoming_state_nr(state_nr_incoming);
 _ret_part.connect_outgoing_transitions_to(state_nr_close, *_dest_state_machine);
 _ret_part.add_outgoing_symbol_transition(state_nr_incoming, Symbol(SymbolKindClose, _callstack[frame_idx_]._nonterminal_idx_cur));

 _nonterminal_idx_to_open_state_nr.erase(_callstack[frame_idx_]._nonterminal_idx_cur);
}</rich_text>
  </node>
</cherrytree>
