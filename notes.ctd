<?xml version="1.0" encoding="UTF-8"?>
<cherrytree>
  <bookmarks list=""/>
  <node name="IntervalContainer" unique_id="2" prog_lang="custom-colors" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161357" ts_lastsave="1745161415">
    <rich_text>  0INSIDE    1INSIDE    2INSIDE
0 [a0, b0] 1 [a1, b1] 2 [a2, b2] 3
 
LOWERS = [a0, a1, a2, ...]
UPPERS = [b0, b1, b2, ...]</rich_text>
  </node>
  <node name="CodeGuidelines" unique_id="6" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161695" ts_lastsave="1745161695">
    <node name="Sections" unique_id="5" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161469" ts_lastsave="1745161534">
      <rich_text>// -$ Types / Constants $-

// -$ Data $-

// -$ Functions $-
// --$ Lifetime $--
// --$ Operators $--
// --$ Inherited: foo::bar::Baz $--
// --$ Other $--</rich_text>
    </node>
    <node name="Conventions" unique_id="7" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1745161743" ts_lastsave="1745161748">
      <rich_text>Concepts in a nested ccpt namespace

type traits in a nested trait namespace,

private use things that are forced to be in headers, should be in a detail namespace

class type aliases should end in "Type"

declare and define getters before setters if possible

boolean functions start with "is_"</rich_text>
    </node>
  </node>
  <node name="ScratchPad" unique_id="4" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="#e5a50a" ts_creation="1745161415" ts_lastsave="1760201506">
    <rich_text>Rename:
parsert: smrt
parsect: smct

State machine runtime (GenericStateMachine?) should take a CRTP interface, specifies a std::integral parameter
-&gt;Generated state machines inherit from this, can use the least needed width integer
-&gt;StateMachine class used for building also inherits from this with uint64_t and thus can also be dynamically run

smrt should provide shallow bitsets

-----------------------------------------------
add some way to iterate over the interval numbers in the interval_{map,set}
+ rename overlap to "clone_and" + "inplace_and", then implement other bitwise operations
+ rename "merge" to "clone_or" + "inplace_or"
+ implement "clone_not" + "inplace_not" &lt;- test this against an interval_set&lt;uint8_t&gt; and a bitset with a size of uint8t_max
+ implement "popcnt"

-----------------------------------------------
bitset or needs to increase size if needed just like and needs to decrease it
-----------------------------------------------
minimizer may not be handling sink state properly now
-----------------------------------------------
for accept bitsets we should not rely on them being the same size, should be possible because and + or may be all we need
+ countl_zero can be wrapped to handle an empty bitset diffrently

-
for handling comment loopbacks, refator out function, take a range of min max, create a huge interval, erase from it all intervals in current state, loop over the remainig and point to 0

----
GraphWriter::accepts_to_label_default can already use the intervals instead of being lazy
---
GrammarData
TerminalStateMachineBuilder
ParserBuilder
---
no need to manually set expression type in TerminalStateMachinePartBuilder, dispatch() can deduce it
--
rename "Rule" to "Nonterminal" ?
---
should add something like GrmBoolean
--
GrammarData only has _whitespace_definition,   pmt::base::IntervalSet&lt;pmt::util::smrt::SymbolType&gt; _whitespace_symbols should be somewhere else like LexerBuilder
---
rename grm_* stuff to own_*
----
change the LexerTables data to private once i figure out how it needs to be accessed
----
implement multi symbol whitespace
rename whitespace to skip
need to check if whitespace conflicts with comment open / multiple starting states is enough of an error?
---
implement case sensitivity
--
fix "" string in terminal definition resulting in null byte
--
emit ids in a list and actually include those where needed
--
use smallest possible integers when emitting lexer or parser tables, offsets is an easy candidate
---
use eytzinger layout and precompute a prev table, use smallest type needed
--
shift the upper and lower bounds by + 1 then we can use small types
--
make skel base class or something similar in pmt_util
--
graphwriter needs to write symbol edges, seperate by symbol kind
this can be done somewhat efficiently by checking all used symbol kinds and then 'and'ing them together with the symbols to
split them by kind, then they need to be written by-kind
----
newline tables passed to the generic lexer
-&gt; take alphabet that loops back to state 0 from the lexer state machine
---
graphviz nodes should be first defined in the proper order
--
rename @start to @skip ?
----
LexerTables::terminal_name_to_index is slow
--
set up the start and end in setup_parser_state_machine
--
rename rule things in the grammar to nonterminal
--
end states looping on themselves is fine in nonterminals, just means it needs lookahead
--
rule building from expressions not done right, probably needs a stack of rule opens but just a map of closes
----
every nonterminal identifier needs to create an open state, but it should point to an existing definition node if on the stack,
the created open + should point to the existing definition, the - should become outgoing
----
minimizer doesn't work right with empty state machines
---
can unpack a rule in the state machine if it cannot reach one of its nonterminal states from any close transition
---
rename terminals and nonterminals to accepts where applicable
--
id_names to id_strings in the generated parsing and lexing tables
--
add a function for returning a span of acceptible terminals from parsertablesbase
+
calculate masks near the end of parsertablebuilder and check for conflicts
--
some modifiers may be incompatible like unpack and id
---
check conflicts twice, one for the nonterminal state machine, one for lookahead,
+
no need to check transition masks in the ParserTableBuilder (?)
---
implement rank feature
hidden terminals
seperate symbol kind instead of bitmasking
---
add a chartype grammar property
---
start accept index needs to be set for each transition mask again
---
parser transitions now need to be written differently since kinds are stored seperately
-&gt; TerminalTransitions
-&gt; HiddenTerminalTransitions
-&gt; OpenTransitions
-&gt; CloseTransitions
-&gt; ConflictTransitions
+
rename upper and lower bounds in lexer skell to the symbol name smt like CharacterSymbolTransitions
---
process_range_stage_0 needs to add a range directly instead of iterating
--
common code can be factored out of lexer_table_writer and parser_table_writer
+
finish changing c style arrays to std::array in the skel files
---
fix duplicate rule definitions
---
conflict resolution not fully working yet, see sandbox_17
+
factor out lookahead generation into another class
---
replace size_t with AcceptsIndexType
---
genericparser should query if a terminal is hidden or not instead of trying to get next state twice
--
name "terminals" visible_terminals to distinguish from hidden ?
---
emit hidden terminal transition masks in parser_table_writer
--
graph writer callbacks should take entire IntervalSets now
--
terminal conflict checking is a bit weird now because it ignores whitespace
+
force whitespace between tokens - toggle with a grammar property?
@whitespace_setting = optional / mandatory &lt;- something like that
+
maybe optional whitespace can just be built into the definition like
@whitespace = " "? makes it optional... this doesnt handle comments
+
===&gt; terminal conflicts should not be a fatal error, just warning and the whitespace and comments should be left as-is
---
genericparser should probably have a static parse fn
---
transformations need to happen on the AST after parsing, the newly created Ids should come after in the enum
---
rm *.svg *.dot; cls &amp;&amp; ~/pmt_parserbuilder_tui -g ~/repos/pmt/src/pmt/parserbuilder/grammar.grm -sl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables.cpp -hl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables.hpp -cl ~/repos/pmt/src/pmt/parserbuilder/grm_lexer_tables-inl.hpp -sp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables.cpp -hp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables.hpp -cp ~/repos/pmt/src/pmt/parserbuilder/grm_parser_tables-inl.hpp -t ~/repos/pmt/src/pmt/parserbuilder/grammar.grm
--
just emit one inl file?
---
transition masks need their own offsets
---
lower bounds + upper bounds + values should be stored back to back since size is the same
kind lookup should also be done in a back to back &lt;kinds&gt; -&gt; &lt;offsets&gt; sorted table
--
rewrite grammar so that repetition expr and sequence modifier and hide is in front
--
inlining should be done on the grammar directly
--
nonterminal inliner should work on the AST alone?
--
define terminal actions
!hide_terminal = {
	$.hide()
};
+ can use logical operators

!parens_to_square = {
 $.empty() || (($.front() == "(" &amp;&amp; $.back() == ")") &amp;&amp; $.front() = "[", $.front() = "]")
};
--
ids should not be seperated for terminals and nonterminals, they should be shared
--
factor out pushing for NonterminalInliner::perform_inline and NonterminalInliner::check_inlineable
--
Generated files:
 LexerTables.{h,c}pp: Inherits from LexerTablesBase
 ParserTables.{h,c}pp: Inherits from ParserTablesBase
 
 GrammarTables.{h,c}pp: Inherits from GrammarTablesBase
 OR (?)
 id_constants-inl.hpp
 id_strings-inl.hpp
 --
 PostParse should create eoi terminal definition, it should also augment the grammar and put eoi after the start rule
 --
 permute needs some way to also allow delimiters... @permute_delimited =&gt; ("a" "b" "c")[@permute_delimited(","~){10#3}];
 + the thing between the parenthesis is any nonterminal choices
 + !!!There is no need to specify if a trailing delimiter is allowed because the user can just make another rule that wraps it or just put the delimiter at the end themselves, so, by default trailing delimiter is not allowed!!!
 --
 advanced regex operations:
 	($t01, $t02, $t03, ...)[@intersect] // String that is matched by all the regexes, need to only implement intersect for two machines at a time
  ($t01, $t02, $t03, ...)[@subtract] // String that is matched by $t01 but not ($t02 or $t03), need to only implement for two machines at a time
COMMA SEPERATED^?
---
ParserTables::get_lookahead_state_terminal_transitions needs to take the current conflict state in the parser
--
logera newline should come lhs?
--
when conflicts are pulled out, only a single accepting state should be created for a given nonterminal currently there are many
--
for intersection we need to prune unreachable

x{,}     = x+ | epsilon
x{2,}   = x x+
x{3,5} = x x x (x x | x | epsilon)
x{,2}   = x x | x | epsilon

------
Operations
CALL &lt;LABEL_ID&gt; = Jumps to a label, sets up a new local return value, after instruction the result is added to the return value of the current frame
JMP &lt;LABEL_ID&gt; = Jumps to a label
DROP &lt;&gt; = Discards the last child of the current return value
PUSH_CNT &lt;N&gt; = Adds a counter to the counter stack
DEC_CNT_JNZ &lt;LABEL_ID&gt; = Decrements the counter at the top of the stack by 1. If not zero: jumps to label, if zero: pop the counter stack and fallthrough to next instruction
MERGE &lt;&gt; = Converts the current return value type to a string
RET &lt;RULE_ID&gt; = Returns control to the previous CALL site, appending this return value to the return value at the call site
BACKTRACK &lt;LABEL_ID&gt; = push backtrack frame
COMMIT &lt;LABEL_ID&gt; = pop one backtrack frame
LITSEQ &lt;LITERAL_ID&gt; = try to consume the literal sequence from input. If success: append to the current return value, otherwise FAIL:
REGULAR &lt;REGEX_ID&gt; = try to match a regular expression rule


No need for an actual label ID in the emitted bytecode, just jump to the PC

regular rules are defined as:
%R1&lt;regular = true&gt; = "abc" | "def";
implies &lt;merge = true&gt;

-----
Printing CharsetLiteral examples...

----
All terminals get converted to state machines, then compatibility matrices are computed.
Terminal state machines get combined based on their compatibility matrices so that the least number of state machines needed are created</rich_text>
  </node>
  <node name="Code dump" unique_id="8" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1746822397" ts_lastsave="1746979052">
    <rich_text> size_t max = 0;
 IntervalSet&lt;StateNrType&gt; state_nrs = _lexer_state_machine.get_state_nrs();
 state_nrs.for_each_key(
  [&amp;](StateNrType state_nr_) {
   State const* state = _lexer_state_machine.get_state(state_nr_);
   Bitset const&amp; accepts = state-&gt;get_accepts();
   size_t const furthest = accepts.size() - accepts.countr(false);
   max = std::max(max, furthest);
  });

  return max;
  ----
  void NonterminalStateMachinePartBuilder::process_nonterminal_identifier_stage_0(size_t frame_idx_){
 GenericAst const&amp; expr_cur = *_callstack[frame_idx_]._expr_cur_path.resolve(*_ast_root);

 std::string const&amp; nonterminal_label = expr_cur.get_string();
 _callstack[frame_idx_]._nonterminal_idx_cur = _fn_rev_lookup_nonterminal_label(nonterminal_label);

 auto itr_close = _nonterminal_idx_to_close_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur);
 if (itr_close == _nonterminal_idx_to_close_state_nr.end()) {
  itr_close = _nonterminal_idx_to_close_state_nr.emplace(_callstack[frame_idx_]._nonterminal_idx_cur, _dest_state_machine-&gt;create_new_state()).first;
  State&amp; state_close = *_dest_state_machine-&gt;get_state(itr_close-&gt;second);
  state_close.get_accepts().resize(_callstack[frame_idx_]._nonterminal_idx_cur + 1, false);
  state_close.get_accepts().set(_callstack[frame_idx_]._nonterminal_idx_cur, true);
 }

 auto itr_open = _nonterminal_idx_to_open_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur);
 if (itr_open == _nonterminal_idx_to_open_state_nr.end()) {
  itr_open = _nonterminal_idx_to_open_state_nr.emplace(_callstack[frame_idx_]._nonterminal_idx_cur, _dest_state_machine-&gt;create_new_state()).first;
  ++_callstack[frame_idx_]._stage;
  _keep_current_frame = true;
  _callstack.emplace_back();
  _callstack.back()._expr_cur_path = _fn_lookup_nonterminal_definition(_callstack[frame_idx_]._nonterminal_idx_cur);
  _callstack.back()._expression_type = _callstack.back()._expr_cur_path.resolve(*_ast_root)-&gt;get_id();
 } else {
  _ret_part.connect_outgoing_transitions_to(itr_open-&gt;second, *_dest_state_machine);
  _ret_part.set_incoming_state_nr(itr_open-&gt;second);
  _ret_part.add_outgoing_symbol_transition(itr_open-&gt;second, Symbol(SymbolKindClose, _callstack[frame_idx_]._nonterminal_idx_cur));
 }
}

void NonterminalStateMachinePartBuilder::process_nonterminal_identifier_stage_1(size_t frame_idx_){
 StateNrType const state_nr_incoming = _nonterminal_idx_to_open_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur)-&gt;second;
 State&amp; state_incoming = *_dest_state_machine-&gt;get_state(state_nr_incoming);
 StateNrType const state_nr_close = _nonterminal_idx_to_close_state_nr.find(_callstack[frame_idx_]._nonterminal_idx_cur)-&gt;second;
 state_incoming.add_symbol_transition(Symbol(SymbolKindOpen, SymbolValueOpen), *_ret_part.get_incoming_state_nr());
 _ret_part.set_incoming_state_nr(state_nr_incoming);
 _ret_part.connect_outgoing_transitions_to(state_nr_close, *_dest_state_machine);
 _ret_part.add_outgoing_symbol_transition(state_nr_incoming, Symbol(SymbolKindClose, _callstack[frame_idx_]._nonterminal_idx_cur));

 _nonterminal_idx_to_open_state_nr.erase(_callstack[frame_idx_]._nonterminal_idx_cur);
}</rich_text>
    <node name="Repetition from ast" unique_id="9" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1757864539" ts_lastsave="1757864553">
      <rich_text>void process_frame_00(Locals&amp; locals_, RepetitionFrame&amp; frame_) {
 frame_._range = RepetitionRange(*frame_._ast_cur_path-&gt;get_child_at(1));

 if (frame_._range.get_upper() == 0) {
  locals_._ret_part = build_epsilon();
  return;
 }

  locals_._keep_current_frame = true;
 ++frame_._stage;

 locals_._callstack.emplace_back(construct_frame(frame_._ast_cur_path-&gt;get_child_at(0)));
}

void process_frame_01(Locals&amp; locals_, RepetitionFrame&amp; frame_) {
 if (!frame_._range.get_upper().has_value()) {
  RuleExpression::UniqueHandle identifier_body = RuleExpression::construct(RuleExpression::Tag::Identifier);
  identifier_body-&gt;set_identifier(EXTRA_RULE_PREFIX + std::to_string(locals_._extra_rules_created++));

  RuleExpression::UniqueHandle identifier_tail = RuleExpression::construct(RuleExpression::Tag::Identifier);
  identifier_tail-&gt;set_identifier(EXTRA_RULE_PREFIX + std::to_string(locals_._extra_rules_created++));

  // Create the body
  Rule&amp; rule_body = locals_._ret.get_or_create_rule(identifier_body-&gt;get_identifier());
  rule_body._parameters._unpack = true;
  rule_body._definition = RuleExpression::clone(*locals_._ret_part);

  // Create the tail
  Rule&amp; rule_tail = locals_._ret.get_or_create_rule(identifier_tail-&gt;get_identifier());
  rule_tail._parameters._unpack = true;

  // Create the tail's expression
  rule_tail._definition = RuleExpression::construct(RuleExpression::Tag::Choice);
  RuleExpression::UniqueHandle expression_tail_seq_0 = RuleExpression::construct(RuleExpression::Tag::Sequence);
  RuleExpression::UniqueHandle expression_tail_seq_0_child_0 = RuleExpression::construct(RuleExpression::Tag::Identifier);
  RuleExpression::UniqueHandle expression_tail_seq_0_child_1 = RuleExpression::construct(RuleExpression::Tag::Identifier);

  expression_tail_seq_0_child_0-&gt;set_identifier(identifier_body-&gt;get_identifier());
  expression_tail_seq_0_child_1-&gt;set_identifier(identifier_tail-&gt;get_identifier());

  expression_tail_seq_0-&gt;give_child_at_back(std::move(expression_tail_seq_0_child_0));
  expression_tail_seq_0-&gt;give_child_at_back(std::move(expression_tail_seq_0_child_1));
  rule_tail._definition-&gt;give_child_at_back(std::move(expression_tail_seq_0));
  rule_tail._definition-&gt;give_child_at_back(RuleExpression::construct(RuleExpression::Tag::Sequence));

  locals_._ret_part = RuleExpression::construct(RuleExpression::Tag::Sequence);
  
  for (size_t i = 0; i &lt; frame_._range.get_lower(); ++i) {
   locals_._ret_part-&gt;give_child_at_back(RuleExpression::clone(*identifier_body));
  }

  locals_._ret_part-&gt;give_child_at_back(RuleExpression::clone(*identifier_tail));
  return;
 }</rich_text>
    </node>
    <node name="IntervalSet::cmp" unique_id="10" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1759531075" ts_lastsave="1759533049">
      <rich_text>template &lt;std::integral KEY_&gt;
auto IntervalSet&lt;KEY_&gt;::cmp(IntervalSet const&amp; lhs_, IntervalSet const&amp; rhs_) -&gt; int {
 for (size_t i = 0; i &lt; std::min(lhs_.size(), rhs_.size()); ++i) {
  if (int const r = (lhs_.get_by_index(i).get_lower() &lt;=&gt; rhs_.get_by_index(i).get_lower()); r != 0) {
    return r;
   }
   if (int const r = (lhs_.get_by_index(i).get_upper() &lt;=&gt; rhs_.get_by_index(i).get_upper()); r != 0) {
    return r;
   }
 }

 return lhs_.size() &lt;=&gt; rhs_.size();
}</rich_text>
    </node>
    <node name="grammar simplifier snapshot" unique_id="11" prog_lang="plain-text" tags="" readonly="0" nosearch_me="0" nosearch_ch="0" custom_icon_id="0" is_bold="0" foreground="" ts_creation="1760291815" ts_lastsave="1760291816">
      <rich_text>#include "pmt/parser/grammar/grammar_simplifier.hpp"

#include "pmt/parser/clause_base.hpp"
#include "pmt/parser/grammar/charset_literal.hpp"
#include "pmt/parser/grammar/grammar.hpp"
#include "pmt/parser/grammar/rule.hpp"

#include &lt;unordered_set&gt;


namespace pmt::parser::grammar {

namespace {

auto concat_charset_literals(CharsetLiteral&amp; lhs_, CharsetLiteral const&amp; rhs_) -&gt; bool {
 if (lhs_.is_hidden() != rhs_.is_hidden()) {
  return false;
 }

 for (size_t i = 0; i &lt; rhs_.size(); ++i) {
  lhs_.push_back(rhs_.get_symbol_set_at(i));
  lhs_.get_symbol_set_at(lhs_.size() - 1) = rhs_.get_symbol_set_at(i);
 }

 return true;
}

auto merge_charset_literals(CharsetLiteral&amp; lhs_, CharsetLiteral const&amp; rhs_) -&gt; bool {
 if (lhs_.size() != rhs_.size() || lhs_.is_hidden() != rhs_.is_hidden()) {
  return false;
 }

 for (size_t i = 0; i &lt; rhs_.size(); ++i) {
  lhs_.get_symbol_set_at(i).inplace_or(rhs_.get_symbol_set_at(i));
  lhs_.get_symbol_set_at(i).inplace_or(rhs_.get_symbol_set_at(i));
 }

 return true;
}

auto get_referenced_rules(RuleExpression const* rule_expression_) -&gt; std::unordered_set&lt;std::string&gt; {
 std::unordered_set&lt;std::string&gt; ret;

 std::vector&lt;RuleExpression const*&gt; pending{rule_expression_};

 auto take = [&amp;]() {
  RuleExpression const* ret = pending.back();
  pending.pop_back();
  return ret;
 };

 while (!pending.empty()) {
  RuleExpression const* cur = take();
  if (cur == nullptr) {
   continue;
  }

  if (cur-&gt;get_tag() == ClauseBase::Tag::Identifier) {
   ret.insert(cur-&gt;get_identifier());
   continue;
  }

  for (size_t i = 0; i &lt; cur-&gt;get_children_size(); ++i) {
   pending.push_back(cur-&gt;get_child_at(i));
  }
 }

 return ret;
}

void prune(Grammar&amp; grammar_) {
 std::unordered_set&lt;std::string&gt; all_rule_names = grammar_.get_rule_names();

 std::vector&lt;std::string&gt; pending;

 auto push_and_visit = [&amp;](std::string const&amp; rule_name_) {
  if (all_rule_names.erase(rule_name_) == 0) {
   return;
  }

  pending.push_back(rule_name_);
 };

 auto take = [&amp;]() {
  std::string ret = pending.back();
  pending.pop_back();
  return ret;
 };

 push_and_visit(grammar_.get_start_rule_name());

 while (!pending.empty()) {
  std::string const cur_rule_name = take();
  Rule const* cur_rule = grammar_.get_rule(cur_rule_name);
  if (cur_rule == nullptr) {
   continue;
  }
  std::unordered_set&lt;std::string&gt; const referenced_rules = get_referenced_rules(cur_rule-&gt;_definition.get());
  for (std::string const&amp; rule_name : referenced_rules) {
   push_and_visit(rule_name);
  }
 }

 // All remaining rule names need to be pruned
 for (std::string const&amp; rule_name : all_rule_names) {
  grammar_.remove_rule(rule_name);
 }
}

void flatten_expression(RuleExpression::UniqueHandle&amp; rule_expression_) {
 class StackItem {
  public:
  RuleExpression* _parent = nullptr;
  size_t _idx;
  bool _in_regular = false;
 };
 
 bool repeat = false;

 do {
  repeat = false;
  std::vector&lt;StackItem&gt; pending;

  for (size_t j = 0; j &lt; rule_expression_-&gt;get_children_size(); ++j) {
   pending.emplace_back(rule_expression_.get(), j);
  }

  while (!pending.empty()) {
   auto [parent, idx, in_regular] = pending.back();
   pending.pop_back();
   RuleExpression* const child = parent-&gt;get_child_at(idx);

   switch (child-&gt;get_tag()) {
    case ClauseBase::Tag::Choice:
     if (child-&gt;get_children_size() == 1) {
      RuleExpression::UniqueHandle grandchild = child-&gt;take_child_at_front();
      parent-&gt;take_child_at(idx);
      parent-&gt;give_child_at(idx, std::move(grandchild));
      pending.emplace_back(parent, idx, in_regular);
      repeat = true;
     } else {
      // Any choices in choices can be immediately flattened
      for (size_t j = 0; j &lt; child-&gt;get_children_size(); ++j) {
       if (child-&gt;get_child_at(j)-&gt;get_tag() != ClauseBase::Tag::Choice) {
        continue;
       }

       RuleExpression::UniqueHandle grandchild = child-&gt;take_child_at(j);
       while (grandchild-&gt;get_children_size() &gt; 0) {
        child-&gt;give_child_at(child-&gt;get_children_size(), grandchild-&gt;take_child_at(grandchild-&gt;get_children_size() - 1));
       }
       j = 0;
       repeat = true;
      }

      // Any neighboring string literals can be merged
      for (size_t j = 0; j + 1 &lt; child-&gt;get_children_size(); ++j) {
       while (j + 1 &lt; child-&gt;get_children_size() &amp;&amp; child-&gt;get_child_at(j)-&gt;get_tag() == ClauseBase::Tag::Literal &amp;&amp; child-&gt;get_child_at(j + 1)-&gt;get_tag() == ClauseBase::Tag::Literal) {
        if (merge_charset_literals(child-&gt;get_child_at(j)-&gt;get_charset_literal(), child-&gt;get_child_at(j + 1)-&gt;get_charset_literal())) {
         child-&gt;take_child_at(j + 1);
        } else {
         ++j;
        }
       }
      }

      // Any neighboring Regular can be merged and have the choice moved inside
      for (size_t j = 0; j + 1 &lt; child-&gt;get_children_size(); ++j) {
       while (j + 1 &lt; child-&gt;get_children_size() &amp;&amp; child-&gt;get_child_at(j)-&gt;get_tag() == ClauseBase::Tag::Regular &amp;&amp; child-&gt;get_child_at(j + 1)-&gt;get_tag() == ClauseBase::Tag::Regular) {
        if (child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;get_tag() != ClauseBase::Tag::Choice) {
         RuleExpression::UniqueHandle tmp = child-&gt;get_child_at(j)-&gt;take_child_at_front();
         child-&gt;get_child_at(j)-&gt;give_child_at_front(RuleExpression::construct(ClauseBase::Tag::Choice));
         child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;give_child_at_back(std::move(tmp));
        }
        child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;give_child_at_back(child-&gt;take_child_at(j + 1));
        repeat = true;
       }
      }

      for (size_t j = 0; j &lt; child-&gt;get_children_size(); ++j) {
       pending.emplace_back(child, j, in_regular);
      }
     }
     break;
    case ClauseBase::Tag::Sequence:
     // Unpack any nested sequences
     for (size_t j = 0; j &lt; child-&gt;get_children_size(); ++j) {
      RuleExpression* const grandchild = child-&gt;get_child_at(j);
      if (grandchild-&gt;get_tag() != ClauseBase::Tag::Sequence) {
       continue;
      }
      child-&gt;unpack(j);
      repeat = true;
      j = 0;
     }
     // Concat neighboring string literals
     for (size_t j = 0; j &lt; child-&gt;get_children_size() - 1; ++j) {
      RuleExpression* const lhs = child-&gt;get_child_at(j);
      RuleExpression* const rhs = child-&gt;get_child_at(j + 1);
      if (lhs-&gt;get_tag() != ClauseBase::Tag::Literal || rhs-&gt;get_tag() != ClauseBase::Tag::Literal) {
       continue;
      }
      concat_charset_literals(lhs-&gt;get_charset_literal(), rhs-&gt;get_charset_literal());
      child-&gt;take_child_at(j + 1);
      repeat = true;
      j = 0;
     }

      // Any neighboring Regular can be merged and have the sequence moved inside
      for (size_t j = 0; j + 1 &lt; child-&gt;get_children_size(); ++j) {
       while (j + 1 &lt; child-&gt;get_children_size() &amp;&amp; child-&gt;get_child_at(j)-&gt;get_tag() == ClauseBase::Tag::Regular &amp;&amp; child-&gt;get_child_at(j + 1)-&gt;get_tag() == ClauseBase::Tag::Regular) {
        if (child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;get_tag() != ClauseBase::Tag::Sequence) {
         RuleExpression::UniqueHandle tmp = child-&gt;get_child_at(j)-&gt;take_child_at_front();
         child-&gt;get_child_at(j)-&gt;give_child_at_front(RuleExpression::construct(ClauseBase::Tag::Sequence));
         child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;give_child_at_back(std::move(tmp));
        }
        child-&gt;get_child_at(j)-&gt;get_child_at_front()-&gt;give_child_at_back(child-&gt;take_child_at(j + 1));
        repeat = true;
       }
      }

     // Remove any epsilons which are not the only child
     for (size_t i = 1; i &lt; child-&gt;get_children_size();) {
      if (child-&gt;get_child_at(i)-&gt;get_tag() == ClauseBase::Tag::Epsilon) {
       child-&gt;take_child_at(i);
      } else {
       ++i;
      }
     }
     if (child-&gt;get_children_size() &gt; 1 &amp;&amp; child-&gt;get_child_at_front()-&gt;get_tag() == ClauseBase::Tag::Epsilon) {
      child-&gt;take_child_at_front();
     }
     if (child-&gt;get_children_size() == 1) {
      RuleExpression::UniqueHandle grandchild = child-&gt;take_child_at_back();
      parent-&gt;take_child_at(idx);
      parent-&gt;give_child_at(idx, std::move(grandchild));
      pending.emplace_back(parent, idx, in_regular);
      repeat = true;
     } else {
      bool hasChoices = false;
      for (size_t j = 0; j &lt; child-&gt;get_children_size(); ++j) {
       if (child-&gt;get_child_at(j)-&gt;get_tag() != ClauseBase::Tag::Choice) {
        continue;
       }
       hasChoices = true;

       RuleExpression::UniqueHandle grandchild = child-&gt;take_child_at(j);
       RuleExpression::UniqueHandle new_choice = RuleExpression::construct(ClauseBase::Tag::Choice);

       for (size_t k = 0; k &lt; grandchild-&gt;get_children_size(); ++k) {
        RuleExpression::UniqueHandle cloned = RuleExpression::clone(*child);
        cloned-&gt;give_child_at(j, RuleExpression::clone(*grandchild-&gt;get_child_at(k)));
        new_choice-&gt;give_child_at(k, std::move(cloned));
       }

       parent-&gt;take_child_at(idx);
       parent-&gt;give_child_at(idx, std::move(new_choice));
       pending.emplace_back(parent, idx, in_regular);
       repeat = true;
       break;
      }
      if (!hasChoices) {
       for (size_t j = 0; j &lt; child-&gt;get_children_size(); ++j) {
        pending.emplace_back(child, j, in_regular);
       }
      }
     }
     break;
    case ClauseBase::Tag::OneOrMore:
    case ClauseBase::Tag::NotFollowedBy:
     pending.emplace_back(child, 0, in_regular);
     break;
    case ClauseBase::Tag::Hidden: {
     switch (child-&gt;get_child_at_front()-&gt;get_tag()) {
      case ClauseBase::Tag::Literal: {
      RuleExpression::UniqueHandle grandchild_replacement = child-&gt;take_child_at_front();
      grandchild_replacement-&gt;get_charset_literal().set_hidden(true);
      parent-&gt;take_child_at(idx);
      parent-&gt;give_child_at(idx, std::move(grandchild_replacement));
      pending.emplace_back(parent, idx, in_regular);
      } break;
      case ClauseBase::Tag::NotFollowedBy:
      case ClauseBase::Tag::OneOrMore:
      case ClauseBase::Tag::Sequence:
      case ClauseBase::Tag::Choice: {
       RuleExpression::UniqueHandle grandchild_replacement = RuleExpression::construct(child-&gt;get_child_at_front()-&gt;get_tag());
       while (child-&gt;get_child_at_front()-&gt;get_children_size() != 0) {
        grandchild_replacement-&gt;give_child_at_back(RuleExpression::construct(ClauseBase::Tag::Hidden));
        grandchild_replacement-&gt;get_child_at_back()-&gt;give_child_at_back(child-&gt;get_child_at_front()-&gt;take_child_at_front());
       }
      parent-&gt;take_child_at(idx);
      parent-&gt;give_child_at(idx, std::move(grandchild_replacement));
      pending.emplace_back(parent, idx, in_regular);
       repeat = true;
      }
      repeat = true;
      break;
      default:
      break;
     }     
    } break;
    case ClauseBase::Tag::Regular: {
     if (in_regular) {
      RuleExpression::UniqueHandle grandchild_replacement = child-&gt;take_child_at_front();
      parent-&gt;take_child_at(idx);
      parent-&gt;give_child_at(idx, std::move(grandchild_replacement));
      pending.emplace_back(parent, idx, true);
     } else {
      pending.emplace_back(child, 0, true);
     }
    } break;
    default:
     break;
   }
  }
 } while (repeat);

 // A definition comes in as a ClauseBase::Tag::Choice, if it has one child we can just unpack it
 if (rule_expression_-&gt;get_tag() == ClauseBase::Tag::Choice &amp;&amp; rule_expression_-&gt;get_children_size() == 1) {
  rule_expression_ = rule_expression_-&gt;take_child_at_back();
 }
}

void flatten(Grammar&amp; grammar_) {
 for (std::string const&amp; rule_name : grammar_.get_rule_names()) {
  Rule* rule = grammar_.get_rule(rule_name);
  if (rule == nullptr || rule-&gt;_definition == nullptr) {
   continue;
  }

  flatten_expression(rule-&gt;_definition);
 }
}
}  // namespace

void GrammarSimplifier::simplify(Args args_) {
 prune(args_._grammar);
 flatten(args_._grammar);
}

}  // namespace pmt::parser::grammar</rich_text>
    </node>
  </node>
</cherrytree>
